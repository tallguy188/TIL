### 코딩 테스트 출제 경향 및 파이썬 문법

* 일반적으로 cpu기반의 개인 컴퓨터나 채점용 컴퓨터에서 연산 횟수가 5억을 넘어가는 경우 python을 기준으로 통상 5~15초가 소요된다. 
* 코딩 테스트 문제에서 시간제한은 통상 1~5초가량
* 혹여 문제에 명시되어 있지 않은 경우 대략 5초 정도라고 생각하고 문제를 푸는 것이 합리적



#### 요구사항에 따라 적절한 알고리즘 설계하기

* 문제에서 가장 먼저 확인해야 하는 내용은 시간제한(수행시간 요구사항)이다
* 시간제한이 1초인 문제를 만났을때, 일반적은 기준은 다음과 같다

>N의 범위가 500인 경우: 시간 복잡도가 O(N^3)인 알고리즘을 설계하면 문제를 풀 수 있다.
>
>N의 범위가 2000인 경우: 시간 복잡도가 O(N^2)인 알고리즘을 설계하면 문제를 풀 수 있다.
>
>N의 범위가 100,000인 경우: 시간 복잡도가 O(NlogN)인 알고리즘을 설계하면 문제를 풀 수 있다. 
>
>N의 범위가 10,000,000인 경우: 시간 복잡도가 O(N)인 알고리즘을 설계하면 문제를 풀 수 있다. 



#### 수행 시간 측정 코드 예제

```python
import time
start_time = time.time() # 측정 시작

# 프로그램 소스코드
end_time = time.time() # 측정 종료
print("time:",end_time - start_time) # 수행시간출력
```





### 자료형

파이썬의 자료형으로는 정수형,실수형,복소수형,문자열,리스트,튜플,사전 등이 있다. 



#### 정수형, 실수형

```python
[1]:정수형
[2]: 실수형
# 소수부가 0일 때 0을 생략
a = 5.
print(a)

#정수부가 0일때 0을 생략
a = -.7
print(a)
```

>지수 표현 방식
>
>파이썬에서는 e나 E를 이용한 지수 표현 방식을 이용할 수 있다. 
>
>e나 E 다음에 오는 수는 10의 지수부를 의미한다. 
>
>예를 들어 1e9라고 입력하게 되면 10의 9제곱이다. 
>
>지수표현방식은 임의의 큰 수를 표현하기 위해 자주 사용된다. 
>
>최단 경로 알고리즘에서는 도달할 수 없는 노드에 대하여 최단 거리를 무한`INF`로 설정하곤 한다. 
>
>이때,  가능한 최댓값이 10억 미만이라면 무한`INF`의 값으로 1e9를 이용할 수 있다. 

##### 실수형 더 알아보기

* 개발 과정에서 실수 값을 제대로 비교하지 못해서 원하는 결과를 얻지 못할 수도 있다. 
* 이럴 때는 round()함수를 이용할 수 있으며, 이러한 방법이 권장된다.
* 예를 들어 123.456을 소수 셋째 자리에서 반올림하려면 round(123.456, 2)라고 작성합니다.
* 결과는 123.46이 된다. 

##### 수 자료형의 연산

* 파이썬에서는 나누기 연산자(/) 를 주의해서 사용해야 한다. 
* 파이썬에서 나누기 연산자(/)는 나눠진 결과를 실수형으로 반환한다. 
* 다양한 로직을 설계할 때 나머지 연산자(%)를 이용해야 한다. 
* 파이썬에서는 몫을 얻기 위해 몫 연산자(//)를 사용한다. 
* 이외에도 거듭 제곱 연산자(**)를 비롯해 다양한 연산자를 사용한다. 



#### 리스트 자료형

* 여러 개의 데이터를 연속적으로 담아 처리하기 위해 사용하는 자료형 
* 리스트 대신에 배열 혹은 테이블이라고 부르기도 한다. 
* 리스트는 대괄호([])안에 원소를 넣어 초기화하며, 쉼표(,)로 원소를 구분한다.
* 비어 있는 리스트를 선언하고자 할때 list()혹은 간단히 []를 이용할 수 있다. 
* 리스트의 원소에 접근할 때는 인덱스 값을 괄호에 넣는다. 

```python
# 크기가 N이고, 모든 값이 0인 1차원 리스트 초기화
n = 10
a = [0] * n
print(a)
```

##### 리스트의 인덱싱과 슬라이싱

* 인덱스 값을 입력하여 리스트의 특정원소에 접근하는 것을 인덱싱이라고 한다.
* 파이썬의 인덱스 값은 양 ,음의정수를 모두 사용할 수 있다.
* 음의 정수를 넣으면 원소를 거꾸로 탐색하게 된다. 

```python
a = [1,2,3,4,5,6,7,8,9]
# 뒤에서 첫번째 원소 출력
print(a[-1])
# 뒤에서 세번째 원소 출력
print(a[-3])
```

* 리스트에서 연속적인 위치를 갖는 원소들을 가져와야 할 때는 슬라이싱을 이용한다.
* 대괄호 안에 콜론(:)을 넣어서 시작인덱스와 끝인덱스를 설정할 수 있다. 
* ***끝 인덱스는 실제 인덱스보다 1을 더 크게 설정한다.***

```python
a = [1,2,3,4,5,6,7,8,9]
# 두번째 원소부터 네번째 원소까지
print(a[1:4]) #[2,3,4]
```

##### 리스트 컴프리핸션

* 리스트를 초기화하는 방법 중 하나
* 대괄호 안에 조건문과 반복문을 적용하여 리스트를 초기화 할 수 있다. 

```python
# 0부터 9까지 수를 포함하는 리스트를 초기화
array = [i for i in range(10)]
print(array)
```

```python
# 0부터 19까지의 수 중에서 홀수만 포함하는 리스트 
array = [i for i in range(20) if i % 2 == 1]
print(array)

# 1부터 9까지의 수들의 제곱 값을 포함하는 리스트
array = [i*i for i in range(1,10)]
print(array)
```

##### 리스트 컴프리핸션과 일반적인 코드 비교

```python
# 0부터 19까지의 수 중에서 홀수만 포함하는 리스트
# 코드 1 : 리스트 컴프리핸션
array = [i for i in range(20) if i % 2 == 1]
print(array)

# 코드 2 : 일반적은 코드
array = []
for i in range(20):
	if i % 2 == 1:
		array.append(i)
print(array)

```

* 특히 리스트 컴프리핸션은 2차원 리스트를 초기화 할때 효과적으로 사용될 수 있다. 
* 특히 N * M  크기의 2차원 리스트를 한번에 초기화 해야 할 때 매우 유용하다. 
* **좋은 예시 : array = [[0] * m for _ in range(n)]**
* 만약 2차원 리스트를 초기화 할 떄 다음과 같이 작성하면 예기치 않은 결과가 나올 수도 있다. 
* **잘못된 예시 : array = [[0] * m] * n**
* 위 코드는 전체 리스트 안에 포함된 각 리스트가 모두 같은 객체로 인식된다. 

##### 언더바는 언제 사용할까?

* 파이썬에서는 반복을 수행하되 반복을 위한 변수의 값을 무시하고자 할 때 **언더바(_)**를 사용한다. 

  ```python
  # Hello world 를 5번 출력하기
  
  for _ in range(5) :
  	print("Hello world")
  ```

  

##### 리스트 관련 기타 메서드

```python
"""
append() :  리스트에 원소를 하나 삽입할 때 사용한다.
sort() : 기본 정렬 기능으로 오름차순으로 정렬한다. 
reverse() : 리스트의 원소의 순소를 모두 뒤집어 놓는다.
insert() : 특정한 인덱스 위치에 원소를 삽입할 때 사용한다. 
count() : 리스트에서 특정한 값을 가지는 데이터의 개수를 셀 때 사용한다. 
remove() : 특정한 값을 갖는 원소를 제거하는데 값을 가진 원소가 여러 개면 하나만 제거한다.
"""
```

```python
# 오름차순 정렬
a = [1,4,3]
a.sort()
print(a) #[1,3,4]

# 내림차순 정렬
a.sort(reverse = True)
print(a) #[4,3,1]
```

```python
# 리스트에서 특정 값을 가지는 원소를 모두 제거하기
a = [1,2,3,4,5,5,5]
remove_set = {3,5} # 집합자료형

# remove_set에 포함되지 않은 값만을 저장
result = [i for i in a if i not in remove_set]
print(result)
```



#### 문자열 자료형

* 문자열 변수를 초기화 할 때는 큰따옴표나 작은 따옴표를 이용한다. 
* 문자열 안에 큰따옴표나 작은따옴표가 포함되어야 하는 경우가 있다. 
* 전체 문자열을 큰따옴표로 구성하는 경우, 내부적으로 작은 따옴표를 포함할 수 있다. 
* 전체 문자열을 작은따옴표로 구성하는 경우, 내부적으로 큰따옴표를 포함할 수 있다. 
* 혹은 백슬래시(\\) 를 사용하면 큰따옴표나 작은따옴표를 원하는 만큼 포함시킬 수 있다. 

```python
data = "Don't you know \"Python\"?"
print(data) # Don't you know "Python"?
```

##### 문자열 연산

* 문자열 변수에 **덧셈(+)** 를 이용하면 문자열이 더해져서 연결[^concatenate] 된다. 
* 문자열 변수를 특정한 양의 정수와 곱하는 경우, 문자열이 그 값만큼 여러번 더해진다. 
* 문자열에 대해서도 마찬가지로 인덱싱과 슬라이싱을 이용할 수 있다. 
* **다만 문자열은 특정 인덱스의 값을 변경할 수는 없다.** 

```python
a = "Hello"
b = "World"
print(a + " " + b) #Hello World

a = "String"
print(a * 3) #StringStringString

a = "ABCDEF"
print(a[2:4]) #CD
```



#### 튜플 자료형

* 튜플 자료형은 리스트와 유사하지만 다음과 같은 문법적 차이가 있다. 
* 튜플은 **한번 선언된 값을 변경할 수 없다.**
* 리스트는 대괄호를 이용하지만 튜플은 소괄호를 이용한다.
* 튜플은 리스트에 비해 상대적으로 공간효율적이다. 

```python
# 튜플 사용 예제 (오류가 발생하는 예제)
a = (1,2,3,4)
print(a)
a[2] = 7
 
#이런식으로 리스트와는 다르게 튜플은 원소를 바꿀 수 없다. 에러가 발생
```

#### 튜플을 사용하면 좋은 경우

* 서로 다른 성질의 데이터를 묶어서 관리해야 할 때
* 최단경로 알고리즘에서는 (비용,노드번호)의 형태로 튜플 자료형을 자주 사용한다.
* 데이터의 나열을 **해싱의 키 값**으로 사용해야 할 때
*  튜플은 변경이 불가능하므로 리스트와 다르게 키 값으로 사용될 수 있다. 
* 리스트보다 **메모리를 효율적으로** 사용해야 할 때



#### 사전 자료형

* 사전 자료형은 **키와 값의 쌍을 데이터로 가지는 자료형**이다. 
* 앞서 다루었던 리스트나 튜플이 값을 순차적으로 저장하는 것과 대비된다.
* 사전 자료형은 키와 값의 쌍을 데이터로 가지며, 원하는 **변경불가능한[^immutable] 자료형** 을 키로 사용 할 수 있다. 
* 파이선의 사전 자료형은 해시 테이블을 이용하므로 데이터의 조회 및 수정에 있어서 O(1)의 시간에 처리할 수 있다. 

```python
data = dict()
data['사과'] = 'Apple'
data['바나나'] = 'Banana'
data['코코넛'] = 'Coconut'

print(data) # {'사과' : 'Apple', '바나나' : 'Banana', '코코넛' : 'Coconut'}

```

* 사전 자료형에서는 키와 값을 별도로 뽑아내기 위한 메서드를 지원한다. 
* 키 데이터만 뽑아서 리스트로 이용할 때는 **key()** 함수를 이용한다.
* 값 데이터만을 뽑아서 리스트로 이용할 때는 **values()**함수를 이용한다.

```python
data = dict()
data['사과'] = 'Apple'
data['바나나'] = 'Banana'
data['코코넛'] = 'Coconut'

key_list = data.keys()
value_list = data.values()
print(key_list)  # dict_keys(['사과','바나나','코코넛'])
print(value_list)  # dict_values(['Apple','Banana','Coconut'])

# 각 키에 따른 값을 하나씩 출력
for key in key_list:
	print(data[key]) 
```



#### 집합 자료형

* 집합은 다음과 같은 특성이 있다. 
* **중복을 허락하지 않는다.**
* **순서가 없다**
* 이러한 특성 덕분에 흔히 어떠한 데이터가 존재하는지 아닌지 그 여부를 판단할 때 많이 사용한다.
* 집합은 **리스트 혹은 문자열을 이용해서 초기화** 할 수 있다.
* 이때 set() 함수를 이용한다.
* 혹은 중괄호({}) 안에 각 원소를 콤마(,)를 기준으로 구분하여 삽입함으로써 초기화 할 수 있다.
* 데이터의 조회 및 수정에 있어서 O(1)의 시간에 처리할 수 있다. 

 ```python
 # 집합 자료형 초기화방법 1
 data = set([1,1,2,3,4,4,5])
 print(data) # {1,2,3,4,5}
 
 # 집합 자료형 초기화 방법 2
 data = {1,1,2,3,4,4,5}
 print(data) # {1,2,3,4,5}
 ```

##### 집합 자료형의 연산

* 기본적으로 집합 자료형의 연산에는 합집합,교집합,차집합이 있다.

##### 사전 자료형과 집합 자료형의 특징

* 리스트나 튜플은 순서가 있기 때문에 인덱싱을 통해 자료형의 값을 얻을 수 있다.
* 사전 자료형과 집합 자료형은 **순서가 없기 때문에 ** 인덱싱으로 값을 얻을 수 없다.
* 사전의 키 혹은 집합의 원소를 이용해 O(1)의 시간 복잡도로 조회한다. 



#### 기본 입출력

##### 자주 사용되는 표준 입력 방법

* input() 함수는 한줄의 문자열을 입력 받는 함수이다. 

* map() 함수는 리스트의 모든 원소에 각각 특정한 함수를 적용할 때 사용한다. 

  ex) 공백을 기준으로 구분된 데이터를 입력 받을 때는 다음과 같이 사용한다. 

  ```python
  list(map(int, input().split()))
  ```

  ex) 공백을 기준으로 구분된 데이터의 개수가 많지 않다면, 단순히 다음과 같이 사용한다. 

  ```python
  a,b,c  = map(int,input().split())
  ```

##### 빠르게 입력 받기

* 사용자로부터 입력을 최대한 빠르게 받아야 하는 경우가 있다. 

* 파이썬의 경우 sys라이브러리에 정의되어 있는 sys.stdin.readline() 메서드를 이용한다.

* 단 입력 후 엔터가 줄 바꿈 기호로 입력되므로 rstrip() 메서드를 함께 사용하도록 한다. 

* 실제로 이진탐색, 정렬, 그래프등에서 자주 사용되는 테크닉이기 때문에 기억해두자

  ```python
  import sys
  
  # 문자열 입력받기
  data = sys.stdin.readline().rstrip()
  print(data)
  ```

##### 자주 사용되는 표준 출력 방법

* 파이썬에서 기본 출력은 print() 함수를 이용한다. 
* 각 변수를 콤마를 이용하여 띄어쓰기로 구분하여 출력할 수 있다. 
* print() 는 기본적으로 출력 이후에 줄 바꿈을 수행한다. 
* 줄 바꿈을 원치 않는 경우 'end'속성을 이용할 수 있다. 

##### f-string 예제

* 문자열 앞에 'f'를 붙여 사용한다. 

* 중괄호 안에 변수명을 기입하여 간단히 문자열과 정수를 함께 넣을 수 있다. 

  ```python
  answer = 7
  print(f"정답은 {answer}입니다")
  # 정답은 7입니다.
  ```



#### 조건문과 반복문

##### 조건문의 기본 형태

* 조건문의 기본적인 형태는 if ~ elif ~ else 입니다. 
* 조건문을 사용할 때 elif혹인 else 부분은 경우에 따라서 사용하지 않아도 된다. 

##### 비교 연산자

* 비교 연산자는 특정한 두 값을 비교할 때 이용할 수 있다. 
* 대입 연산자(=) 와 같음 연산자(==) 의 차의점에 주의하자. 

##### 논리 연산자

* 논리 연산자는 논리 값(True/False) 사이의 연산을 수행할 때 사용된다. 

##### 파이썬의 기타 연산자

* 다수의 데이터를 담는 자료형을 위해 **in연산자** 와 **not in연산자** 가 제공된다. 

* 리스트, 튜플,문자열,딕셔너리 모두에서 사용이 가능하다.

  ```python
  x in 리스트 
  # 리스트 안에 x가 들어가 있을 때 참(True)이다. 
  x not in 문자열 
  # 문자열 안에 x가 들어가 있지 않을 때 참(True)이다. 
  ```

##### 파이썬의 pass 키워드

* 아무것도 처리하고 싶지 않을 때 pass키워드를 사용한다.

* 예를 들어 디버깅 과정에서 일단 조건문의 형태만 만들어 놓고 조건문을 처리하는 부분은 비워놓고 싶은 경우 사용가능하다.

  ```python
  score = 85
  
  if score >= 80:
  	pass # 나중에 작성할 소스코드
  else: 
  	print('성적이 80점 미만입니다.')
  
  print('프로그램을 종료합니다.')
  
  # 출력결과
  # 프로그램을 종료합니다.
  ```

##### 조건문의 간소화

* 조건문에서 실행될 소스코드가 한줄인 경우, 굳이 줄바꿈을 하지 않고도 간소화 할 수 있다. 

  ```python
  score = 85
  if score >= 80: result = "Success"
  else: result = "Fail"
  ```

  

* 조건부 표현식은 if~else문을 한줄에 작성할 수 있도록 해준다.

  ```python
  score = 85
  result = "Success" if score >= 80 else "Fail"
  print(result)
  ```

##### 파이썬 조건문 내에서의 부등식

* 다른 프로그래밍 언어와 다르게 파이썬은 조건문 안에서 수학의 부등식을 그대로 사용할 수 있다.
* 예를 들어 **x>0 and x<20 과 0<x<20** 은 같은 결과를 반환한다. 



##### 반복문에서의 무한 루프

* 무한 루프[^infinite loop] 란 끊임없이 반복되는 반복 구문을 의미한다. 
* 코딩 테스트에서는 무한 루프를 구현할 일은 거의 없다.
* 반복문을 작성한 뒤에는 항상 반복문을 탈출할 수 있는지 확인해야 한다.
* 
