### 코딩 테스트 출제 경향 및 파이썬 문법

* 일반적으로 cpu기반의 개인 컴퓨터나 채점용 컴퓨터에서 연산 횟수가 5억을 넘어가는 경우 python을 기준으로 통상 5~15초가 소요된다. 
* 코딩 테스트 문제에서 시간제한은 통상 1~5초가량
* 혹여 문제에 명시되어 있지 않은 경우 대략 5초 정도라고 생각하고 문제를 푸는 것이 합리적



#### 요구사항에 따라 적절한 알고리즘 설계하기

* 문제에서 가장 먼저 확인해야 하는 내용은 시간제한(수행시간 요구사항)이다
* 시간제한이 1초인 문제를 만났을때, 일반적은 기준은 다음과 같다

>N의 범위가 500인 경우: 시간 복잡도가 O(N^3)인 알고리즘을 설계하면 문제를 풀 수 있다.
>
>N의 범위가 2000인 경우: 시간 복잡도가 O(N^2)인 알고리즘을 설계하면 문제를 풀 수 있다.
>
>N의 범위가 100,000인 경우: 시간 복잡도가 O(NlogN)인 알고리즘을 설계하면 문제를 풀 수 있다. 
>
>N의 범위가 10,000,000인 경우: 시간 복잡도가 O(N)인 알고리즘을 설계하면 문제를 풀 수 있다. 



#### 수행 시간 측정 코드 예제

```python
import time
start_time = time.time() # 측정 시작

# 프로그램 소스코드
end_time = time.time() # 측정 종료
print("time:",end_time - start_time) # 수행시간출력
```





### 자료형

파이썬의 자료형으로는 정수형,실수형,복소수형,문자열,리스트,튜플,사전 등이 있다. 



#### 정수형, 실수형

```python
[1]:정수형
[2]: 실수형
# 소수부가 0일 때 0을 생략
a = 5.
print(a)

#정수부가 0일때 0을 생략
a = -.7
print(a)
```

>지수 표현 방식
>
>파이썬에서는 e나 E를 이용한 지수 표현 방식을 이용할 수 있다. 
>
>e나 E 다음에 오는 수는 10의 지수부를 의미한다. 
>
>예를 들어 1e9라고 입력하게 되면 10의 9제곱이다. 
>
>지수표현방식은 임의의 큰 수를 표현하기 위해 자주 사용된다. 
>
>최단 경로 알고리즘에서는 도달할 수 없는 노드에 대하여 최단 거리를 무한`INF`로 설정하곤 한다. 
>
>이때,  가능한 최댓값이 10억 미만이라면 무한`INF`의 값으로 1e9를 이용할 수 있다. 

##### 실수형 더 알아보기

* 개발 과정에서 실수 값을 제대로 비교하지 못해서 원하는 결과를 얻지 못할 수도 있다. 
* 이럴 때는 round()함수를 이용할 수 있으며, 이러한 방법이 권장된다.
* 예를 들어 123.456을 소수 셋째 자리에서 반올림하려면 round(123.456, 2)라고 작성합니다.
* 결과는 123.46이 된다. 

##### 수 자료형의 연산

* 파이썬에서는 나누기 연산자(/) 를 주의해서 사용해야 한다. 
* 파이썬에서 나누기 연산자(/)는 나눠진 결과를 실수형으로 반환한다. 
* 다양한 로직을 설계할 때 나머지 연산자(%)를 이용해야 한다. 
* 파이썬에서는 몫을 얻기 위해 몫 연산자(//)를 사용한다. 
* 이외에도 거듭 제곱 연산자(**)를 비롯해 다양한 연산자를 사용한다. 



#### 리스트 자료형

* 여러 개의 데이터를 연속적으로 담아 처리하기 위해 사용하는 자료형 
* 리스트 대신에 배열 혹은 테이블이라고 부르기도 한다. 
* 리스트는 대괄호([])안에 원소를 넣어 초기화하며, 쉼표(,)로 원소를 구분한다.
* 비어 있는 리스트를 선언하고자 할때 list()혹은 간단히 []를 이용할 수 있다. 
* 리스트의 원소에 접근할 때는 인덱스 값을 괄호에 넣는다. 

```python
# 크기가 N이고, 모든 값이 0인 1차원 리스트 초기화
n = 10
a = [0] * n
print(a)
```

##### 리스트의 인덱싱과 슬라이싱

* 인덱스 값을 입력하여 리스트의 특정원소에 접근하는 것을 인덱싱이라고 한다.
* 파이썬의 인덱스 값은 양 ,음의정수를 모두 사용할 수 있다.
* 음의 정수를 넣으면 원소를 거꾸로 탐색하게 된다. 

```python
a = [1,2,3,4,5,6,7,8,9]
# 뒤에서 첫번째 원소 출력
print(a[-1])
# 뒤에서 세번째 원소 출력
print(a[-3])
```

* 리스트에서 연속적인 위치를 갖는 원소들을 가져와야 할 때는 슬라이싱을 이용한다.
* 대괄호 안에 콜론(:)을 넣어서 시작인덱스와 끝인덱스를 설정할 수 있다. 
* ***끝 인덱스는 실제 인덱스보다 1을 더 크게 설정한다.***

```python
a = [1,2,3,4,5,6,7,8,9]
# 두번째 원소부터 네번째 원소까지
print(a[1:4]) #[2,3,4]
```

##### 리스트 컴프리핸션

* 리스트를 초기화하는 방법 중 하나
* 대괄호 안에 조건문과 반복문을 적용하여 리스트를 초기화 할 수 있다. 

```python
# 0부터 9까지 수를 포함하는 리스트를 초기화
array = [i for i in range(10)]
print(array)
```

```python
# 0부터 19까지의 수 중에서 홀수만 포함하는 리스트 
array = [i for i in range(20) if i % 2 == 1]
print(array)

# 1부터 9까지의 수들의 제곱 값을 포함하는 리스트
array = [i*i for i in range(1,10)]
print(array)
```

##### 리스트 컴프리핸션과 일반적인 코드 비교

```python
# 0부터 19까지의 수 중에서 홀수만 포함하는 리스트
# 코드 1 : 리스트 컴프리핸션
array = [i for i in range(20) if i % 2 == 1]
print(array)

# 코드 2 : 일반적은 코드
array = []
for i in range(20):
	if i % 2 == 1:
		array.append(i)
print(array)

```

* 특히 리스트 컴프리핸션은 2차원 리스트를 초기화 할때 효과적으로 사용될 수 있다. 
* 특히 N * M  크기의 2차원 리스트를 한번에 초기화 해야 할 때 매우 유용하다. 
* **좋은 예시 : array = [[0] * m for _ in range(n)]**
* 만약 2차원 리스트를 초기화 할 떄 다음과 같이 작성하면 예기치 않은 결과가 나올 수도 있다. 
* **잘못된 예시 : array = [[0] * m] * n**
* 위 코드는 전체 리스트 안에 포함된 각 리스트가 모두 같은 객체로 인식된다. 

##### 언더바는 언제 사용할까?

* 파이썬에서는 반복을 수행하되 반복을 위한 변수의 값을 무시하고자 할 때 **언더바(_)**를 사용한다. 

  ```python
  # Hello world 를 5번 출력하기
  
  for _ in range(5) :
  	print("Hello world")
  ```

  

##### 리스트 관련 기타 메서드

```python
"""
append() :  리스트에 원소를 하나 삽입할 때 사용한다.
sort() : 기본 정렬 기능으로 오름차순으로 정렬한다. 
reverse() : 리스트의 원소의 순소를 모두 뒤집어 놓는다.
insert() : 특정한 인덱스 위치에 원소를 삽입할 때 사용한다. 
count() : 리스트에서 특정한 값을 가지는 데이터의 개수를 셀 때 사용한다. 
remove() : 특정한 값을 갖는 원소를 제거하는데 값을 가진 원소가 여러 개면 하나만 제거한다.
"""
```

```python
# 오름차순 정렬
a = [1,4,3]
a.sort()
print(a) #[1,3,4]

# 내림차순 정렬
a.sort(reverse = True)
print(a) #[4,3,1]
```

```python
# 리스트에서 특정 값을 가지는 원소를 모두 제거하기
a = [1,2,3,4,5,5,5]
remove_set = {3,5} # 집합자료형

# remove_set에 포함되지 않은 값만을 저장
result = [i for i in a if i not in remove_set]
print(result)
```



#### 문자열 자료형

* 문자열 변수를 초기화 할 때는 큰따옴표나 작은 따옴표를 이용한다. 
* 문자열 안에 큰따옴표나 작은따옴표가 포함되어야 하는 경우가 있다. 
* 전체 문자열을 큰따옴표로 구성하는 경우, 내부적으로 작은 따옴표를 포함할 수 있다. 
* 전체 문자열을 작은따옴표로 구성하는 경우, 내부적으로 큰따옴표를 포함할 수 있다. 
* 혹은 백슬래시(\\) 를 사용하면 큰따옴표나 작은따옴표를 원하는 만큼 포함시킬 수 있다. 

```python
data = "Don't you know \"Python\"?"
print(data) # Don't you know "Python"?
```

##### 문자열 연산

* 문자열 변수에 **덧셈(+)** 를 이용하면 문자열이 더해져서 연결[^concatenate] 된다. 
* 문자열 변수를 특정한 양의 정수와 곱하는 경우, 문자열이 그 값만큼 여러번 더해진다. 
* 문자열에 대해서도 마찬가지로 인덱싱과 슬라이싱을 이용할 수 있다. 
* **다만 문자열은 특정 인덱스의 값을 변경할 수는 없다.** 

```python
a = "Hello"
b = "World"
print(a + " " + b) #Hello World

a = "String"
print(a * 3) #StringStringString

a = "ABCDEF"
print(a[2:4]) #CD
```



#### 튜플 자료형

* 튜플 자료형은 리스트와 유사하지만 다음과 같은 문법적 차이가 있다. 
* 튜플은 **한번 선언된 값을 변경할 수 없다.**
* 리스트는 대괄호를 이용하지만 튜플은 소괄호를 이용한다.
* 튜플은 리스트에 비해 상대적으로 공간효율적이다. 

```python
# 튜플 사용 예제 (오류가 발생하는 예제)
a = (1,2,3,4)
print(a)
a[2] = 7
 
#이런식으로 리스트와는 다르게 튜플은 원소를 바꿀 수 없다. 에러가 발생
```

#### 튜플을 사용하면 좋은 경우

* 서로 다른 성질의 데이터를 묶어서 관리해야 할 때
* 최단경로 알고리즘에서는 (비용,노드번호)의 형태로 튜플 자료형을 자주 사용한다.
* 데이터의 나열을 **해싱의 키 값**으로 사용해야 할 때
*  튜플은 변경이 불가능하므로 리스트와 다르게 키 값으로 사용될 수 있다. 
* 리스트보다 **메모리를 효율적으로** 사용해야 할 때



#### 사전 자료형

* 사전 자료형은 **키와 값의 쌍을 데이터로 가지는 자료형**이다. 
* 앞서 다루었던 리스트나 튜플이 값을 순차적으로 저장하는 것과 대비된다.
* 사전 자료형은 키와 값의 쌍을 데이터로 가지며, 원하는 **변경불가능한[^immutable] 자료형** 을 키로 사용 할 수 있다. 
* 파이선의 사전 자료형은 해시 테이블을 이용하므로 데이터의 조회 및 수정에 있어서 O(1)의 시간에 처리할 수 있다. 

```python
data = dict()
data['사과'] = 'Apple'
data['바나나'] = 'Banana'
data['코코넛'] = 'Coconut'

print(data) # {'사과' : 'Apple', '바나나' : 'Banana', '코코넛' : 'Coconut'}

```

* 사전 자료형에서는 키와 값을 별도로 뽑아내기 위한 메서드를 지원한다. 
* 키 데이터만 뽑아서 리스트로 이용할 때는 **key()** 함수를 이용한다.
* 값 데이터만을 뽑아서 리스트로 이용할 때는 **values()**함수를 이용한다.

```python
data = dict()
data['사과'] = 'Apple'
data['바나나'] = 'Banana'
data['코코넛'] = 'Coconut'

key_list = data.keys()
value_list = data.values()
print(key_list)  # dict_keys(['사과','바나나','코코넛'])
print(value_list)  # dict_values(['Apple','Banana','Coconut'])

# 각 키에 따른 값을 하나씩 출력
for key in key_list:
	print(data[key]) 
```



#### 집합 자료형

* 집합은 다음과 같은 특성이 있다. 
* **중복을 허락하지 않는다.**
* **순서가 없다**
* 이러한 특성 덕분에 흔히 어떠한 데이터가 존재하는지 아닌지 그 여부를 판단할 때 많이 사용한다.
* 집합은 **리스트 혹은 문자열을 이용해서 초기화** 할 수 있다.
* 이때 set() 함수를 이용한다.
* 혹은 중괄호({}) 안에 각 원소를 콤마(,)를 기준으로 구분하여 삽입함으로써 초기화 할 수 있다.
* 데이터의 조회 및 수정에 있어서 O(1)의 시간에 처리할 수 있다. 

 ```python
 # 집합 자료형 초기화방법 1
 data = set([1,1,2,3,4,4,5])
 print(data) # {1,2,3,4,5}
 
 # 집합 자료형 초기화 방법 2
 data = {1,1,2,3,4,4,5}
 print(data) # {1,2,3,4,5}
 ```

##### 집합 자료형의 연산

* 기본적으로 집합 자료형의 연산에는 합집합,교집합,차집합이 있다.

##### 사전 자료형과 집합 자료형의 특징

* 리스트나 튜플은 순서가 있기 때문에 인덱싱을 통해 자료형의 값을 얻을 수 있다.
* 사전 자료형과 집합 자료형은 **순서가 없기 때문에 ** 인덱싱으로 값을 얻을 수 없다.
* 사전의 키 혹은 집합의 원소를 이용해 O(1)의 시간 복잡도로 조회한다. 



